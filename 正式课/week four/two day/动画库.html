<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="css/reset.min.css">
    <style>
        #box{
            position: relative;
            left: 0;
            top: 0;
            width: 50px;
            height: 50px;
            background: red;
            opacity:1;
            font-size: 16px;
            text-align: center;
            line-height: 50px;
        }
    </style>

</head>
<body>
<div class="box" id="box">帅呆</div>
</body>
</html>

<script>
    //=>需求 : 让BOX盒子从左边运到右边
    let minL=0,
        maxL=document.documentElement.clientWidth-box.offsetWidth;
    //
    // //=>[固定步长的匀速运动]
    // let step=5,
    //     aotoTimer=setInterval(()=>{
    //         let curL=box.offsetLeft;//=>用左偏移代替获取left值
    //         curL+=step;
    //         //=>先加步长,判断是否走这一步会大于等于最大值
    //         if(curL>=maxL){
    //             //=>固定步长的情况下左边界判断 : 都是先加上步长在做判断,验证如果走着一步会不会超 , 如果超了 , 我们直接运动到末尾即可 ,没超才走一步
    //             box.style.left=maxL+'px';
    //             clearTimeout(aotoTimer);
    //             return
    //         }
    //         box.style.left=curL+'px';
    //     },17);//=>17/13 都是比较好的动画执行时间 (浏览器不出现卡顿)
    //

    //=>[固定时间的匀速运动]
    // ~function () {
    //     let duration=1000,//=>总时间
    //         interval=17,//=>频率 : 多长时间迈一步
    //         change=max-0;
        //=>第一种思路 : 步长 : 总距离/总时间*频率,剩下变为固定步长的匀速运动了
        //2. 在JS中基于定时器完成动画 , 不论是固定步长还是固定时间,只要算出当前盒子应该运动的位置即可 (新的位置信息)

    //t : time 当前运动的时间
        //: begin 起始位置
        //c: 总距离   (target-begin)
        //d :duration 总时间

    //   t/d=>当前动画完成的百分比
        //  t/d*c: 当前动画完成的百分比 *总距离 => 当前已经走的距离
        //t/d*c+b : 当前走的距离 + 盒子的起始距离 => 当前盒子应该有的位置
    // }();

    // ~function () {
    //     let duration=1000,
    //         interval=17,
    //         begin=0,
    //         target=maxL,
    //         change=target-begin,
    //         time=0;
    //
    //     let autoTimer=setInterval(()=>{
    //         //=>根据公式当前盒子应该有的位置
    //         time+=interval;
    //         if(time>=duration){
    //             box.style.left=target+'px';
    //             clearTimeout(autoTimer);
    //             return ;
    //         }
    //         let curL=time/duration*change+begin;
    //         box.style.left=curL+'px'
    //     },interval)
    // }();

    // ~function () {
    //     //=>固定时间之内的多方向匀速运动
    //     /*
    //     * time 当前运动时间
    //     * duration 总时间
    //     *
    //     * [记录每一个方向的起始位置,目标值,总距离]
    //     * begin 起始位置
    //     * target 目标位置
    //     * change 总距离
    //     * */
    //     let time=0,
    //         duration=4000;
    //     let target={
    //         left:document.documentElement.clientWidth-box.offsetWidth,
    //         top:document.documentElement.clientHeight-box.offsetHeight,
    //         width:120,
    //         height:120,
    //         fontSize:28,
    //         lineHeight:120
    //     };
    //
    //     //=>根据目标值计算出当前元素每一个运动方法的总距离 (前提计算出每个方向的起始值)
    //     let change={},
    //         begin={};
    //     for (let attr in target) {
    //         if (!target.hasOwnProperty(attr)) break;
    //         begin[attr]=parseFloat(window.getComputedStyle(box)[attr]);
    //         change[attr]=target[attr]-begin[attr]
    //     }
    //     let animateTimer=setInterval(()=>{
    //         time+=17;
    //         if(time>=duration){
    //             clearInterval(animateTimer);
    //             for (let key in target) {
    //                 if (!target.hasOwnProperty(key)) break;
    //                 box.style[key]=target[key]+'px';
    //             }
    //             return
    //         }
    //
    //         let cur={};
    //         //=>根据目标值的方向,基于公式计算出每一个方向的当前位置
    //         for (let attr in target ) {
    //             if (!target.hasOwnProperty(attr)) break;
    //             cur[attr]=time/duration*change[attr]+begin[attr];
    //         }
    //         for (let key in cur) {
    //             if (!cur.hasOwnProperty(key)) break;
    //             box.style[key]=cur[key]+'px';
    //         }
    //     },17)
    // }();


</script>